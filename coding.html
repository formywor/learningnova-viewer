<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Coding Editor</title>
    <style>
        body {
            margin: 0;
            font-family: Arial, sans-serif;
            height: 100vh;
            display: flex;
            flex-direction: column;
        }
        #toolbar {
            background: #333;
            color: white;
            padding: 10px;
            display: flex;
            align-items: center;
            gap: 10px;
            flex-wrap: wrap;
        }
        #language {
            padding: 5px;
            background: #555;
            color: white;
            border: none;
            border-radius: 3px;
        }
        #run-btn, #analyze-btn, #save-btn, #load-btn, #theme-btn, #generate-btn {
            padding: 5px 10px;
            background: #007acc;
            color: white;
            border: none;
            border-radius: 3px;
            cursor: pointer;
        }
        #run-btn:hover, #analyze-btn:hover, #save-btn:hover, #load-btn:hover, #theme-btn:hover, #generate-btn:hover {
            background: #005a9e;
        }
        #generate-btn {
            background: #ff6b35;
        }
        #generate-btn:hover {
            background: #e55a2b;
        }
        #file-input {
            display: none;
        }
        #container {
            display: flex;
            flex: 1;
        }
        #editor-container {
            flex: 1;
            border-right: 1px solid #ccc;
            min-width: 0; /* Ensure flex child can shrink */
        }
        #preview-container {
            flex: 1;
            padding: 10px;
            overflow: auto;
            background: #f5f5f5;
        }
        #output {
            margin-top: 10px;
            padding: 10px;
            background: #fff;
            border: 1px solid #ddd;
            border-radius: 3px;
            white-space: pre-wrap;
            font-family: monospace;
        }
        #errors {
            margin-top: 10px;
            padding: 10px;
            background: #ffebee;
            border: 1px solid #f44336;
            border-radius: 3px;
            color: #c62828;
            font-family: monospace;
        }
        #suggestions {
            margin-top: 10px;
            padding: 10px;
            background: #e3f2fd;
            border: 1px solid #2196f3;
            border-radius: 3px;
        }
        #suggestions h4 {
            margin-top: 0;
        }
        .suggestion-item {
            border: 1px solid #ddd;
            padding: 10px;
            margin: 5px 0;
            border-radius: 3px;
            position: relative;
        }
        .suggestion-item.error {
            background: #ffebee;
            border-color: #f44336;
        }
        .suggestion-item.warning {
            background: #fff3cd;
            border-color: #ffc107;
        }
        .suggestion-item.info {
            background: #d1ecf1;
            border-color: #17a2b8;
        }
        .accept-btn {
            position: absolute;
            top: 5px;
            right: 5px;
            padding: 2px 6px;
            background: #28a745;
            color: white;
            border: none;
            border-radius: 2px;
            cursor: pointer;
            font-size: 12px;
            opacity: 0;
            transition: opacity 0.2s;
        }
        .suggestion-item:hover .accept-btn {
            opacity: 1;
        }
        .accept-btn:hover {
            background: #218838;
        }
        .line-fix-btn {
            background: #17a2b8;
        }
        .line-fix-btn:hover {
            background: #138496;
        }
        #status {
            font-size: 12px;
            color: #666;
            margin-left: auto;
        }
        #stats {
            font-size: 11px;
            color: #888;
            margin-top: 5px;
        }
    </style>
    <!-- Monaco Editor - Updated to latest version -->
    <script src="https://cdnjs.cloudflare.com/ajax/libs/monaco-editor/0.53.0/min/vs/loader.min.js"></script>
    <!-- Pyodide for Python - Updated to latest -->
    <script src="https://cdn.jsdelivr.net/pyodide/v0.29.0/full/pyodide.js"></script>
    <!-- Wasmoon for Lua - Updated to latest -->
    <script src="https://cdn.jsdelivr.net/npm/wasmoon@1.16.0/dist/wasmoon.js"></script>
</head>
<body>
    <div id="toolbar">
        <label for="language">Language:</label>
        <select id="language">
            <option value="html">HTML</option>
            <option value="python">Python</option>
            <option value="lua">Lua</option>
        </select>
        <button id="run-btn">Run</button>
        <button id="analyze-btn">Analyze</button>
        <button id="save-btn">Save</button>
        <label for="file-input" id="load-btn" style="cursor: pointer; padding: 5px 10px; background: #007acc; color: white; border-radius: 3px;">Load</label>
        <input type="file" id="file-input" accept=".txt,.html,.py,.lua">
        <button id="theme-btn">Toggle Theme</button>
        <button id="generate-btn">Generate Code (BETA)</button>
        <div id="status">Loading...</div>
        <div id="stats"></div>
    </div>
    <div id="container">
        <div id="editor-container"></div>
        <div id="preview-container">
            <h3>Preview/Output</h3>
            <div id="preview"></div>
            <div id="output"></div>
            <div id="errors"></div>
            <div id="suggestions"></div>
        </div>
    </div>

    <script>
        let editor;
        let pyodide;
        let luaEngine;
        let currentOutput = '';
        let currentErrors = '';
        let fixes = {};
        let currentTheme = 'vs-dark';

        // HARDCODED OPENAI API KEY - REPLACE WITH YOUR OWN 'sk-...' KEY HERE
        // WARNING: This is visible in the page source! Anyone can see and use it. For production, use a backend proxy.
        const API_KEY = 'sk-proj-esQZvuHfktHXvSoEtfPRy-IZuDRXYWSTrtphEqUXFlTds,1tOHtjZzg3daCpD_VzKs7yT0I8p_HT3BlbkFJFlcclxKg8g_R6gscPp1gekMQXtDmVkwzkKY6Y4LJtSGfDxC7EMVWj16dzS9sM-dz3TaRb52zkA'; // e.g., 'sk-proj-abc123...'

        async function initPyodide() {
            try {
                pyodide = await loadPyodide({
                    indexURL: "https://cdn.jsdelivr.net/pyodide/v0.29.0/full/"
                });
                updateStatus('Pyodide loaded');
            } catch (err) {
                console.error('Pyodide load error:', err);
                updateStatus('Pyodide failed: ' + err.message);
            }
        }

        async function initLua() {
            try {
                const { LuaFactory } = window.wasmoon;
                const factory = new LuaFactory();
                luaEngine = await factory.createEngine();
                // Override print for Lua
                luaEngine.global.set('print', (...args) => {
                    let out = '';
                    for (let i = 0; i < args.length; i++) {
                        if (i > 0) out += '\t';
                        let arg = args[i];
                        if (typeof arg === 'number') out += arg.toString();
                        else if (typeof arg === 'string') out += arg;
                        else out += JSON.stringify(arg);
                    }
                    currentOutput += out + '\n';
                    return 0;
                });
                updateStatus(' | Lua loaded');
            } catch (err) {
                console.error('Lua load error:', err);
                updateStatus(' | Lua failed');
            }
        }

        function updateStatus(text) {
            const statusEl = document.getElementById('status');
            const current = statusEl.textContent;
            statusEl.textContent = current ? current + text : text;
        }

        function updateStats() {
            if (!editor) return;
            const model = editor.getModel();
            const value = model.getValue();
            const lines = value.split('\n').length;
            const chars = value.length;
            document.getElementById('stats').textContent = `${lines} lines | ${chars} chars`;
        }

        function initEditor() {
            return new Promise((resolve, reject) => {
                require.config({ paths: { vs: 'https://cdnjs.cloudflare.com/ajax/libs/monaco-editor/0.53.0/min/vs' } });
                require(['vs/editor/editor.main'], function () {
                    try {
                        // Register languages if needed
                        ['html', 'python', 'lua'].forEach(langId => {
                            if (!monaco.languages.getLanguages().find(l => l.id === langId)) {
                                monaco.languages.register({ id: langId });
                            }
                        });

                        // Basic completions for Python
                        monaco.languages.registerCompletionItemProvider('python', {
                            provideCompletionItems: () => ({
                                suggestions: [
                                    { 
                                        label: 'print', 
                                        kind: monaco.languages.CompletionItemKind.Function, 
                                        insertText: 'print($1)', 
                                        insertTextRules: monaco.languages.CompletionItemInsertTextRule.InsertAsSnippet 
                                    },
                                    { 
                                        label: 'def', 
                                        kind: monaco.languages.CompletionItemKind.Keyword, 
                                        insertText: 'def ${1:function}($2):\n\t$0', 
                                        insertTextRules: monaco.languages.CompletionItemInsertTextRule.InsertAsSnippet 
                                    }
                                ]
                            })
                        });

                        // Basic completions for Lua
                        monaco.languages.registerCompletionItemProvider('lua', {
                            provideCompletionItems: () => ({
                                suggestions: [
                                    { 
                                        label: 'print', 
                                        kind: monaco.languages.CompletionItemKind.Function, 
                                        insertText: 'print($1)', 
                                        insertTextRules: monaco.languages.CompletionItemInsertTextRule.InsertAsSnippet 
                                    },
                                    { 
                                        label: 'function', 
                                        kind: monaco.languages.CompletionItemKind.Keyword, 
                                        insertText: 'function ${1:name}($2)\n\t$0\nend', 
                                        insertTextRules: monaco.languages.CompletionItemInsertTextRule.InsertAsSnippet 
                                    }
                                ]
                            })
                        });

                        editor = monaco.editor.create(document.getElementById('editor-container'), {
                            value: '<h1>Hello World!</h1>',
                            language: 'html',
                            theme: currentTheme,
                            automaticLayout: true,
                            lineNumbers: 'on',
                            minimap: { enabled: false },
                            scrollBeyondLastLine: false,
                            wordWrap: 'on'
                        });

                        // Event listener for stats update
                        editor.onDidChangeModelContent(updateStats);

                        // Register Code Action Provider for all supported languages
                        ['python', 'lua', 'html'].forEach(langId => {
                            monaco.languages.registerCodeActionProvider(langId, {
                                provideCodeActions: function(model, range, context, token) {
                                    if (context.markers.length === 0 || Object.keys(fixes).length === 0) {
                                        return { actions: [], dispose: () => {} };
                                    }
                                    const marker = context.markers.find(m => 
                                        m.severity === monaco.MarkerSeverity.Error || 
                                        m.severity === monaco.MarkerSeverity.Warning
                                    );
                                    if (!marker) {
                                        return { actions: [], dispose: () => {} };
                                    }
                                    const line = marker.startLineNumber;
                                    const fixObj = fixes[line];
                                    if (!fixObj) {
                                        return { actions: [], dispose: () => {} };
                                    }
                                    const lineLength = model.getLineLength(line);
                                    return {
                                        actions: [{
                                            title: `AI Fix: ${marker.message.substring(0, 30)}...`,
                                            diagnostics: context.markers,
                                            edit: {
                                                edits: [{
                                                    resource: model.uri,
                                                    versionId: model.getVersionId(),
                                                    textChanges: [{
                                                        range: {
                                                            startLineNumber: line,
                                                            startColumn: 1,
                                                            endLineNumber: line,
                                                            endColumn: lineLength + 1
                                                        },
                                                        text: fixObj.fix
                                                    }]
                                                }]
                                            },
                                            kind: monaco.languages.CodeActionKind.QuickFix
                                        }],
                                        dispose: () => {}
                                    };
                                }
                            });
                        });

                        // Load saved code if exists
                        const saved = localStorage.getItem('savedCode');
                        const savedLang = localStorage.getItem('savedLang');
                        if (saved) {
                            editor.setValue(saved);
                            if (savedLang) {
                                document.getElementById('language').value = savedLang;
                                monaco.editor.setModelLanguage(editor.getModel(), savedLang);
                            }
                        }
                        updateStats();

                        updateStatus(' | Editor ready');
                        resolve();
                    } catch (err) {
                        console.error('Editor init error:', err);
                        reject(err);
                    }
                }, reject); // Error callback for require
            });
        }

        async function analyzeCode() {
            if (API_KEY === 'sk-PLACEHOLDER_REPLACE_WITH_YOUR_KEY') {
                alert('Please replace the API_KEY placeholder in the code with your actual OpenAI key (sk-...).');
                return;
            }
            let key = API_KEY.replace(/,/g, '').trim(); // Ignore commas if any
            if (!key.startsWith('sk-')) {
                alert('Invalid API key format. Must start with "sk-".');
                return;
            }
            const code = editor.getValue();
            const lang = document.getElementById('language').value;
            if (!code.trim()) {
                alert('No code to analyze.');
                return;
            }
            updateStatus(' | Analyzing deeply...');
            try {
                const response = await fetch('https://api.openai.com/v1/chat/completions', {
                    method: 'POST',
                    headers: {
                        'Authorization': `Bearer ${key}`,
                        'Content-Type': 'application/json'
                    },
                    body: JSON.stringify({
                        model: 'gpt-4o-mini',
                        messages: [
                            {
                                role: 'system',
                                content: `You are an expert code reviewer for ${lang}. Perform a DEEP analysis: Check syntax errors, logical bugs, edge cases, performance bottlenecks, security vulnerabilities (e.g., injections, leaks), adherence to best practices (PEP8 for Python, semantic HTML, Lua idioms), code style/readability, scalability, and optimizations. Suggest refactoring for clarity/efficiency.

Output ONLY valid JSON object with:

{
  "errors": [
    {
      "line": 1-based line number (integer),
      "message": brief description (string),
      "severity": "error" | "warning" | "info",
      "fix": the replacement text for the entire line (string)
    }
  ],
  "suggestions": [
    {
      "message": detailed description (string),
      "severity": "info",
      "fix": optional snippet to insert/replace at a specific spot (string),
      "line": optional 1-based line number for insertion/replacement (integer)
    }
  ]
}

Be thorough: Cover structure, variables, functions, loops, conditions, I/O, and potential runtime issues. For suggestions, prefer targeted snippets over full code. Do not include any other text.`
                            },
                            { role: 'user', content: `Language: ${lang}\n\nCode:\n${code}` }
                        ],
                        temperature: 0.1,
                        max_tokens: 3000 // Increased for deeper analysis
                    })
                });

                if (!response.ok) {
                    const errorText = await response.text();
                    throw new Error(`API error: ${response.status} ${response.statusText} - ${errorText}`);
                }

                const data = await response.json();
                const content = data.choices[0].message.content.trim();
                const analysis = JSON.parse(content);

                // Set markers for errors/warnings
                const markers = analysis.errors.filter(e => e.severity !== 'info').map(err => ({
                    severity: err.severity === 'error' ? monaco.MarkerSeverity.Error : 
                              err.severity === 'warning' ? monaco.MarkerSeverity.Warning : monaco.MarkerSeverity.Info,
                    message: err.message,
                    startLineNumber: err.line,
                    startColumn: 1,
                    endLineNumber: err.line,
                    endColumn: 100 // Approximate for underline
                }));
                monaco.editor.setModelMarkers(editor.getModel(), 'ai-linter', markers);

                // Store fixes (whole line)
                fixes = {};
                analysis.errors.forEach(err => {
                    fixes[err.line] = { fix: err.fix };
                });

                // Store suggestions with lines if available
                analysis.suggestions.forEach(sugg => {
                    if (sugg.line) {
                        fixes[sugg.line] = { fix: sugg.fix, type: 'suggestion' };
                    }
                });

                // Display all items (errors + suggestions) with hover buttons
                const allItems = [...analysis.errors, ...analysis.suggestions];
                const suggDiv = document.getElementById('suggestions');
                let suggHtml = '<h4>Analysis Results:</h4>';
                if (allItems.length === 0) {
                    suggHtml += '<p>No issues found. Great code!</p>';
                } else {
                    suggHtml += allItems.map(item => {
                        const className = item.severity === 'error' ? 'error' : 
                                          item.severity === 'warning' ? 'warning' : 'info';
                        let btnText = 'Dismiss';
                        let btnAction = 'this.parentElement.remove()';
                        let btnClass = '';
                        if (item.fix) {
                            if (item.line) {
                                btnText = 'Accept Line Fix';
                                btnAction = `applyLineFix(${item.line})`;
                                btnClass = 'line-fix-btn';
                            } else {
                                btnText = 'Accept Full Suggestion';
                                btnAction = `applyFullFix('${item.fix.replace(/'/g, "\\'")}')`;
                            }
                        }
                        return `
                            <div class="suggestion-item ${className}">
                                <h5>${item.severity.toUpperCase()}: ${item.message}</h5>
                                ${item.line ? `<p>Line: ${item.line}</p>` : ''}
                                ${item.fix ? `<p><em>Suggested Fix/Snippet:</em> ${item.fix}</p>` : ''}
                                <button class="accept-btn ${btnClass}" onclick="${btnAction}">${btnText}</button>
                            </div>
                        `;
                    }).join('');
                }
                suggDiv.innerHTML = suggHtml;

                updateStatus(` | Deep analysis: ${analysis.errors.length} issues, ${analysis.suggestions.length} suggestions`);
            } catch (err) {
                console.error(err);
                alert('Deep analysis failed: ' + err.message);
                updateStatus(' | Analysis failed');
            }
        }

        function applyLineFix(line) {
            if (fixes[line]) {
                const model = editor.getModel();
                const lineLength = model.getLineLength(line);
                model.applyEdits([{
                    range: {
                        startLineNumber: line,
                        startColumn: 1,
                        endLineNumber: line,
                        endColumn: lineLength + 1
                    },
                    text: fixes[line].fix
                }]);
                // Remove the corresponding suggestion item
                const items = document.querySelectorAll('.suggestion-item');
                items.forEach(item => {
                    if (parseInt(item.querySelector('p').textContent.match(/Line: (\d+)/)?.[1]) === line) {
                        item.remove();
                    }
                });
                // Clear markers for this line
                const markers = monaco.editor.getModelMarkers(editor.getModel());
                const filteredMarkers = markers.filter(m => m.startLineNumber !== line);
                monaco.editor.setModelMarkers(editor.getModel(), 'ai-linter', filteredMarkers);
                updateStats();
            }
        }

        function applyFullFix(fixCode) {
            if (confirm('This will replace your entire code with the suggestion. Continue?')) {
                editor.setValue(fixCode);
                // Clear analysis
                monaco.editor.setModelMarkers(editor.getModel(), 'ai-linter', []);
                fixes = {};
                document.getElementById('suggestions').innerHTML = '';
                updateStats();
                runCode(); // Auto-preview
            }
        }

        async function generateCode() {
            const lang = document.getElementById('language').value;
            if (lang !== 'html') {
                if (!confirm('Generate Code is HTML-only. Switch to HTML and continue?')) {
                    return;
                }
                document.getElementById('language').value = 'html';
                monaco.editor.setModelLanguage(editor.getModel(), 'html');
            }
            const userPrompt = prompt('What do you want to make? (e.g., "a responsive landing page for a coffee shop")');
            if (!userPrompt) return;
            if (API_KEY === 'sk-PLACEHOLDER_REPLACE_WITH_YOUR_KEY') {
                alert('Please replace the API_KEY placeholder in the code with your actual OpenAI key (sk-...).');
                return;
            }
            let key = API_KEY.replace(/,/g, '').trim();
            if (!key.startsWith('sk-')) {
                alert('Invalid API key format. Must start with "sk-".');
                return;
            }
            updateStatus(' | Generating code...');
            try {
                const response = await fetch('https://api.openai.com/v1/chat/completions', {
                    method: 'POST',
                    headers: {
                        'Authorization': `Bearer ${key}`,
                        'Content-Type': 'application/json'
                    },
                    body: JSON.stringify({
                        model: 'gpt-4o-mini',
                        messages: [
                            {
                                role: 'system',
                                content: `You are an expert HTML/CSS/JS developer. Generate complete, valid, self-contained HTML code (including inline styles if needed) for the user's request. Make it modern, responsive, and functional. Output ONLY the full HTML code, no explanations. Start with <!DOCTYPE html> and end with </html>.`
                            },
                            { role: 'user', content: userPrompt }
                        ],
                        temperature: 0.3,
                        max_tokens: 4000
                    })
                });

                if (!response.ok) {
                    const errorText = await response.text();
                    throw new Error(`API error: ${response.status} ${response.statusText} - ${errorText}`);
                }

                const data = await response.json();
                const generatedCode = data.choices[0].message.content.trim();
                editor.setValue(generatedCode);
                updateStats();
                runCode(); // Show in preview
                updateStatus(' | Code generated!');
            } catch (err) {
                console.error(err);
                alert('Generation failed: ' + err.message);
                updateStatus(' | Generation failed');
            }
        }

        async function runCode() {
            if (!editor) {
                console.warn('Editor not ready');
                return;
            }
            const code = editor.getValue();
            const lang = document.getElementById('language').value;
            const preview = document.getElementById('preview');
            const outputDiv = document.getElementById('output');
            const errorsDiv = document.getElementById('errors');
            currentOutput = '';
            currentErrors = '';

            monaco.editor.setModelLanguage(editor.getModel(), lang);

            if (lang === 'html') {
                preview.innerHTML = `<iframe id="frame" style="width:100%; height:400px; border:1px solid #ccc;"></iframe>`;
                const frame = document.getElementById('frame');
                frame.srcdoc = code;
                outputDiv.innerHTML = '';
                errorsDiv.innerHTML = '';
            } else {
                preview.innerHTML = '<h4>Output:</h4>';
                outputDiv.innerHTML = '';
                errorsDiv.innerHTML = '';
                try {
                    if (lang === 'python') {
                        if (!pyodide) throw new Error('Pyodide not loaded');
                        await pyodide.runPythonAsync(code, {
                            stdout: (text) => { currentOutput += text; },
                            stderr: (text) => { currentErrors += text; }
                        });
                    } else if (lang === 'lua') {
                        if (!luaEngine) throw new Error('Lua not loaded');
                        luaEngine.doString(code); // Sync
                    }
                    outputDiv.innerHTML = currentOutput || 'No output.';
                    if (currentErrors) {
                        errorsDiv.innerHTML = currentErrors;
                    }
                } catch (err) {
                    errorsDiv.innerHTML = err.message || String(err);
                }
            }
        }

        function saveCode() {
            const code = editor.getValue();
            const lang = document.getElementById('language').value;
            localStorage.setItem('savedCode', code);
            localStorage.setItem('savedLang', lang);
            // No alert to avoid annoyance on auto-save
        }

        function loadCode(event) {
            const file = event.target.files[0];
            if (file) {
                const reader = new FileReader();
                reader.onload = (e) => {
                    editor.setValue(e.target.result);
                    updateStats();
                };
                reader.readAsText(file);
            }
        }

        function toggleTheme() {
            currentTheme = currentTheme === 'vs-dark' ? 'vs-light' : 'vs-dark';
            monaco.editor.setTheme(editor, currentTheme);
        }

        // Event listeners
        document.getElementById('language').addEventListener('change', (e) => {
            const lang = e.target.value;
            const initialCode = lang === 'html' ? '<h1>Hello World!</h1>' :
                                lang === 'python' ? 'print("Hello, Python!")' :
                                'print("Hello, Lua!")';
            if (editor) {
                editor.setValue(initialCode);
                monaco.editor.setModelLanguage(editor.getModel(), lang);
                // Clear analysis
                monaco.editor.setModelMarkers(editor.getModel(), 'ai-linter', []);
                fixes = {};
                document.getElementById('suggestions').innerHTML = '';
            }
            updateStats();
        });

        document.getElementById('run-btn').addEventListener('click', runCode);
        document.getElementById('analyze-btn').addEventListener('click', analyzeCode);
        document.getElementById('save-btn').addEventListener('click', saveCode);
        document.getElementById('file-input').addEventListener('change', loadCode);
        document.getElementById('theme-btn').addEventListener('click', toggleTheme);
        document.getElementById('generate-btn').addEventListener('click', generateCode);

        // Auto-save every 30 seconds
        setInterval(saveCode, 30000);

        // Start initialization
        async function start() {
            document.getElementById('status').textContent = 'Initializing...';
            fixes = {};
            try {
                await Promise.all([initPyodide(), initLua()]);
                await initEditor();
                // Now run initial code
                runCode();
            } catch (err) {
                updateStatus(' | Init failed: ' + err.message);
                console.error('Start error:', err);
            }
        }
        start();
    </script>
</body>
</html>
